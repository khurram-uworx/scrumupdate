@page "/"
@using ScrumUpdate.Web.Data
@using ScrumUpdate.Web.Services
@inject ChatSessionService SessionService
@inject IChatClient ChatClient
@inject IScrumUpdateGenerator ScrumUpdateGenerator
@inject ScrumUpdateTools ScrumUpdateTools
@implements IAsyncDisposable

<PageTitle>Scrum Update</PageTitle>

<ChatHeader />

<ChatMessageList Messages="@messages.ToArray()" InProgressMessage="@currentResponseMessage">
    <NoMessagesContent>
        <div>Welcome to Scrum Update! Start a conversation with the AI assistant.</div>
    </NoMessagesContent>
</ChatMessageList>

<div class="chat-container">
    <ChatSuggestions OnSelected="@OnAddUserMessageAsync" @ref="@chatSuggestions" />
    <ChatInput OnSend="@OnAddUserMessageAsync" @ref="@chatInput" />
    <SurveyPrompt />
</div>

@code {
    const string SystemPrompt = @"""
        You are a helpful assistant. Provide clear and concise responses.

        When the user asks for a scrum update or asks to regenerate one, call the GenerateScrumUpdateDraftAsync tool.

        If the tool returns a scrum update, generate user's scrum update using the returned information,
        it must have what one did, what one will do and blocker sections.

        Use only simple markdown to format your responses.
        ";

    readonly ChatOptions chatOptions = new();
    readonly List<ChatMessage> messages = [];
    readonly Dictionary<ChatMessage, ChatMessageMetadata> messageMetadata = [];

    ChatInput? chatInput;
    ChatSuggestions? chatSuggestions;
    ChatSession? currentSession;
    ChatMessage? currentResponseMessage;
    CancellationTokenSource? currentResponseCancellation;

    int statefulMessageCount;
    bool initialized;
    int handledNewChatVersion = -1;

    [CascadingParameter(Name = "CurrentSessionId")]
    public int? RequestedSessionId { get; set; }

    [CascadingParameter(Name = "NewChatVersion")]
    public int NewChatVersion { get; set; }

    [CascadingParameter(Name = "OnSessionChanged")]
    public Func<int, Task>? OnSessionChanged { get; set; }

    protected override async Task OnParametersSetAsync()
    {
        if (!initialized)
        {
            initialized = true;
            handledNewChatVersion = NewChatVersion;
            await InitializeAsync();

            if (RequestedSessionId is int initialSessionId && initialSessionId != currentSession?.Id)
            {
                await LoadSessionAsync(initialSessionId);
                await FocusInputAsync();
            }

            return;
        }

        if (NewChatVersion != handledNewChatVersion)
        {
            handledNewChatVersion = NewChatVersion;
            await CreateNewChatAsync();
            await FocusInputAsync();
            return;
        }

        if (RequestedSessionId is int sessionId && sessionId != currentSession?.Id)
        {
            await LoadSessionAsync(sessionId);
            await FocusInputAsync();
        }
    }

    async Task InitializeAsync()
    {
        statefulMessageCount = 0;
        messages.Clear();
        messageMetadata.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));
        chatOptions.Tools = [AIFunctionFactory.Create(ScrumUpdateTools.GenerateScrumUpdateDraftAsync)];
    }

    async Task CreateNewChatAsync()
    {
        CancelAnyCurrentResponse();
        await SaveCurrentSessionAsync();
        currentSession = null;

        messages.Clear();
        messageMetadata.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));
        chatOptions.ConversationId = null;
        statefulMessageCount = 0;

        chatSuggestions?.Clear();
        StateHasChanged();
    }

    async Task LoadSessionAsync(int sessionId)
    {
        CancelAnyCurrentResponse();
        await SaveCurrentSessionAsync();

        var session = await SessionService.GetSessionAsync(sessionId);
        if (session == null)
        {
            return;
        }

        currentSession = session;
        messages.Clear();
        messageMetadata.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));

        if (session.Messages is { Count: > 0 })
        {
            foreach (var messageEntity in session.Messages)
            {
                var role = messageEntity.Role.ToLowerInvariant() switch
                {
                    "user" => ChatRole.User,
                    "assistant" => ChatRole.Assistant,
                    _ => ChatRole.System
                };

                var message = new ChatMessage(role, [new TextContent(messageEntity.Content)]);
                var metadata = ChatSessionService.DeserializeMetadata(messageEntity.MetadataJson);
                if (metadata != null)
                {
                    messageMetadata[message] = metadata;
                }

                messages.Add(message);
            }
        }

        chatOptions.ConversationId = null;
        statefulMessageCount = 0;

        chatSuggestions?.Update(messages);
        await NotifySessionChangedAsync();
        StateHasChanged();
    }

    async Task OnAddUserMessageAsync(ChatMessage userMessage)
    {
        await AddUserMessageAndGetResponseAsync(userMessage);
        chatSuggestions?.Update(messages);
        await FocusInputAsync();
    }

    async Task AddUserMessageAndGetResponseAsync(ChatMessage userMessage)
    {
        CancelAnyCurrentResponse();
        messages.Add(userMessage);
        StateHasChanged();

        var responseText = new TextContent(string.Empty);
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
        currentResponseCancellation = new();
        ScrumUpdateTools.ResetCapturedGeneratedUpdates();
        StateHasChanged();

        try
        {
            await foreach (var update in ChatClient.GetStreamingResponseAsync(
                messages.Skip(statefulMessageCount),
                chatOptions,
                currentResponseCancellation.Token))
            {
                messages.AddMessages(update, filter: c => c is not TextContent);
                responseText.Text += update.Text;
                chatOptions.ConversationId = update.ConversationId;
                StateHasChanged();
            }

            messages.Add(currentResponseMessage!);
            statefulMessageCount = chatOptions.ConversationId is not null ? messages.Count : 0;
            currentResponseMessage = null;
            StateHasChanged();
        }
        catch (OperationCanceledException)
        {
            messages.Add(currentResponseMessage!);
            currentResponseMessage = null;
            StateHasChanged();
        }

        var lastAssistantMessage = messages.LastOrDefault(m => m.Role == ChatRole.Assistant);
        var generatedScrumUpdate = ScrumUpdateTools.TryConsumeLatestGeneratedUpdate();

        if (generatedScrumUpdate == null && lastAssistantMessage != null)
        {
            var assistantText = ExtractMessageContent(lastAssistantMessage);
            generatedScrumUpdate = ScrumUpdateGenerator.TryParseGeneratedScrumUpdateFromAssistantMessage(assistantText);
        }

        if (generatedScrumUpdate != null)
        {
            if (lastAssistantMessage != null)
            {
                messageMetadata[lastAssistantMessage] = new ScrumGenerationMetadata
                {
                    ScrumUpdate = generatedScrumUpdate,
                    CapturedAtUtc = DateTime.UtcNow
                };
            }

            await EnsureScrumSessionAsync(generatedScrumUpdate);
        }

        await SaveCurrentSessionAsync();
        await NotifySessionChangedAsync();
    }

    async Task EnsureScrumSessionAsync(GeneratedScrumUpdate generatedScrumUpdate)
    {
        var session = await SessionService.GetOrCreateSessionForScrumUpdateAsync(generatedScrumUpdate);

        if (currentSession?.Id == session.Id)
        {
            currentSession = session;
            return;
        }

        var transientMessages = messages
            .Where(m => m.Role == ChatRole.User || m.Role == ChatRole.Assistant)
            .Select(m =>
            {
                var transientMessage = new ChatMessage(m.Role, [new TextContent(ExtractMessageContent(m))]);
                messageMetadata.TryGetValue(m, out var metadata);
                return (Message: transientMessage, Metadata: metadata);
            })
            .ToList();

        currentSession = session;
        messages.Clear();
        messageMetadata.Clear();
        messages.Add(new(ChatRole.System, SystemPrompt));

        if (session.Messages is { Count: > 0 })
        {
            foreach (var messageEntity in session.Messages.OrderBy(m => m.Timestamp).ThenBy(m => m.Id))
            {
                var role = messageEntity.Role.ToLowerInvariant() switch
                {
                    "user" => ChatRole.User,
                    "assistant" => ChatRole.Assistant,
                    _ => ChatRole.System
                };

                var message = new ChatMessage(role, [new TextContent(messageEntity.Content)]);
                var metadata = ChatSessionService.DeserializeMetadata(messageEntity.MetadataJson);
                if (metadata != null)
                {
                    messageMetadata[message] = metadata;
                }

                messages.Add(message);
            }
        }

        if (transientMessages.Count > 0)
        {
            foreach (var (message, metadata) in transientMessages)
            {
                if (metadata != null)
                {
                    messageMetadata[message] = metadata;
                }

                messages.Add(message);
            }
        }

        chatOptions.ConversationId = null;
        statefulMessageCount = 0;
        chatSuggestions?.Update(messages);
        await NotifySessionChangedAsync();
    }

    async Task SaveCurrentSessionAsync()
    {
        if (currentSession == null || messages.Count <= 1)
        {
            return;
        }

        var messagesToSave = messages
            .Where(m => m.Role != ChatRole.System)
            .Select(m =>
            {
                messageMetadata.TryGetValue(m, out var metadata);
                return (Role: m.Role.ToString(), Content: ExtractMessageContent(m), Metadata: metadata);
            })
            .Where(m => !string.IsNullOrWhiteSpace(m.Content))
            .ToList();

        if (messagesToSave.Count == 0)
        {
            return;
        }

        await SessionService.SaveSessionAsync(currentSession.Id, messagesToSave);
    }

    async Task NotifySessionChangedAsync()
    {
        if (currentSession != null && OnSessionChanged != null)
        {
            await OnSessionChanged.Invoke(currentSession.Id);
        }
    }

    static string ExtractMessageContent(ChatMessage message)
    {
        if (message.Contents == null || message.Contents.Count == 0)
        {
            return string.Empty;
        }

        var textContents = message.Contents
            .OfType<TextContent>()
            .Select(c => c.Text)
            .Where(t => !string.IsNullOrWhiteSpace(t));

        return string.Concat(textContents);
    }

    void CancelAnyCurrentResponse()
    {
        if (currentResponseMessage is not null)
        {
            messages.Add(currentResponseMessage);
            StateHasChanged();
        }

        currentResponseCancellation?.Cancel();
        currentResponseMessage = null;
    }

    async Task FocusInputAsync()
    {
        if (chatInput != null)
        {
            await chatInput.FocusAsync();
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        currentResponseCancellation?.Cancel();
        currentResponseCancellation?.Dispose();
        await SaveCurrentSessionAsync();
    }
}
